import os
import glob
import cv2
import numpy as np
import random

# Add filters to imagaes for augmentation

def apply_weather_effects(image, effect_type):
    """
    Apply weather/hue effects to an image with HSV
    
    Args:
        image: Input image to modify
        effect_type: Type of weather effect to apply: "rainy", "sunset", or "darker"
        
    Returns:
        Modified and horizontally flipped image with applied weather effect
    """
    h, w = image.shape[:2]

    # Convert BGR to HSV color space for easier color manipulation
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

    # Apply different effects based on the selected type
    if effect_type == "rainy":
        # Rainy effect: cooler tones, increased saturation, reduced brightness
        hsv[:, :, 0] = (hsv[:, :, 0] * 0.8) % 180  # Shift hue toward blue (cooler)
        hsv[:, :, 1] = hsv[:, :, 1] * 1.3          # Increase saturation (more vivid colors)
        hsv[:, :, 2] = hsv[:, :, 2] * 0.5          # Reduce brightness (darker, overcast look)
        
    elif effect_type == "sunset":
        # Sunset effect: warm orange/red tones, high saturation, reduced brightness
        hsv[:, :, 0] = (hsv[:, :, 0] * 0.6) % 180  # Shift hue toward red/orange (warmer)
        hsv[:, :, 1] = hsv[:, :, 1] * 1.5          # Greatly increase saturation
        hsv[:, :, 2] = hsv[:, :, 2] * 0.6          # Reduce brightness (dusk lighting)
        
    elif effect_type == "darker":
        # Simple darkening effect: significantly reduce brightness only
        hsv[:, :, 2] = hsv[:, :, 2] * 0.2          # Drastically reduce brightness

    # Convert back to BGR color space
    image_modified = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
    
    # Apply horizontal flip for additional data augmentation
    image_modified = cv2.flip(image_modified, 1)  # 1 = flip around vertical axis
    
    # Ensure pixel values stay within valid range [0, 255]
    return np.clip(image_modified, 0, 255).astype(np.uint8)

def load_annotations(label_file):
    """
    Load YOLO format annotation file
    
    Args:
        label_file: Path to the annotation file
        
    Returns:
        List of annotation dictionaries with class_id, bbox, and seg_points
    """
    annotations = []
    with open(label_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # Parse each line in the annotation file
    for line in lines:
        parts = line.strip().split()
        if len(parts) < 5:
            continue  # Skip invalid lines (need at least class_id + bbox)
            
        # Extract components: class_id, bounding box, and optional segmentation points
        cls = int(parts[0])  # Object class ID
        bbox = list(map(float, parts[1:5]))  # [center_x, center_y, width, height] in normalized coords
        seg_points = list(map(float, parts[5:])) if len(parts) > 5 else []  # Optional segmentation points
        
        annotations.append({
            'class_id': cls, 
            'bbox': bbox, 
            'seg_points': seg_points
        })
    
    return annotations

def flip_annotations(annotations):
    """
    Flip bounding boxes and segmentation points
    
    Args:
        annotations: List of annotation dictionaries
        
    Returns:
        New list of annotations with horizontally flipped coordinates
    """
    new_annotations = []
    
    for ann in annotations:
        new_ann = ann.copy()  # Create a copy to avoid modifying original
        
        # Flip bounding box center x-coordinate
        cx, cy, bw, bh = ann['bbox']
        new_ann['bbox'][0] = 1 - cx  # Mirror x-center across vertical axis
        
        # Flip segmentation points (x-coordinates only)
        flipped_seg_points = []
        for i in range(0, len(ann['seg_points']), 2):
            x = ann['seg_points'][i]      # Current x coordinate
            y = ann['seg_points'][i+1]    # Current y coordinate
            flipped_seg_points.extend([1 - x, y])  # Flip x, keep y unchanged
        
        new_ann['seg_points'] = flipped_seg_points
        new_annotations.append(new_ann)
    
    return new_annotations

def save_annotations(annotations, output_file):
    """
    Save structured annotations back to YOLO format text file
    
    Args:
        annotations: List of annotation dictionaries to save
        output_file: Path where to save the annotations
    """
    with open(output_file, 'w', encoding='utf-8') as f:
        for ann in annotations:
            # Format: class_id bbox_coords [segmentation_points]
            line = f"{ann['class_id']} " + " ".join(f"{x:.6f}" for x in ann['bbox'])
            
            # Add segmentation points if they exist
            if ann['seg_points']:
                line += " " + " ".join(f"{x:.6f}" for x in ann['seg_points'])
            
            f.write(line + "\n")

# =========
# Main loop
# =========
def main():
    """
    Main function to process images and apply weather effects with annotation updates
    """
    # Set up directory paths
    base_dir = os.path.dirname(os.path.abspath(__file__))  # Current script directory
    img_dir = os.path.join(base_dir, "img")                # Input images directory
    ann_dir = os.path.join(base_dir, "ann")                # Input annotations directory

    # Create output directory structure
    output_base_dir = os.path.join(base_dir, "hue_change")
    output_img_dir = os.path.join(output_base_dir, "img")  # Output images directory
    output_ann_dir = os.path.join(output_base_dir, "ann")  # Output annotations directory
    os.makedirs(output_img_dir, exist_ok=True)
    os.makedirs(output_ann_dir, exist_ok=True)

    # Gather all image files with supported extensions
    image_extensions = ["*.png", "*.jpg", "*.jpeg"]
    image_files = []
    for ext in image_extensions:
        # Search for both lowercase and uppercase extensions
        image_files.extend(glob.glob(os.path.join(img_dir, ext)))
        image_files.extend(glob.glob(os.path.join(img_dir, ext.upper())))
    print(f"Found {len(image_files)} images")

    # Match images with existing annotation files
    valid_pairs = []
    for image_file in image_files:
        image_filename = os.path.basename(image_file)
        label_file = os.path.join(ann_dir, image_filename + ".txt")  # Annotation file path
        
        if os.path.exists(label_file):
            try:
                # Verify annotation file is not empty
                with open(label_file, 'r', encoding='utf-8') as f:
                    lines = [line.strip() for line in f.readlines() if line.strip()]
                if lines:  # Only add if file has valid content
                    valid_pairs.append((image_file, label_file))
            except Exception as e:
                print(f"Error reading {label_file}: {e}")

    print(f"Found {len(valid_pairs)} valid image-annotation pairs")

    # Exit if no valid pairs found
    if not valid_pairs:
        print("No valid pairs found")
        return

    # How many to process
    max_process = 1500
    images_to_process = valid_pairs[-max_process:] if len(valid_pairs) > max_process else valid_pairs
    print(f"Processing {len(images_to_process)} images")

    # Available weather effects to randomly choose from
    effect_types = ["rainy", "sunset", "darker"]

    # Process each image-annotation pair
    for img_path, ann_path in images_to_process:
        # Load image
        img = cv2.imread(img_path)
        if img is None:
            print(f"Could not read image: {img_path}")
            continue

        # Prepare output filenames
        base_name = os.path.splitext(os.path.basename(img_path))[0]
        
        # Apply random weather effect
        selected_effect = random.choice(effect_types)
        modified_img = apply_weather_effects(img, selected_effect)

        # Load and flip annotations to match the horizontally flipped image
        annotations = load_annotations(ann_path)
        flipped_annotations = flip_annotations(annotations)

        # Save modified image with "_hue" suffix
        new_img_name = f"{base_name}_hue.jpg"
        new_img_path = os.path.join(output_img_dir, new_img_name)
        cv2.imwrite(new_img_path, modified_img)

        # Save flipped annotations with "_hue" suffix
        new_ann_name = f"{base_name}_hue.txt"
        new_ann_path = os.path.join(output_ann_dir, new_ann_name)
        save_annotations(flipped_annotations, new_ann_path)

    print("Done processing all images")

if __name__ == "__main__":
    main()
